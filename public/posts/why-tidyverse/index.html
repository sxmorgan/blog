<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>data&#43;science/posts/why-tidyverse/</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="all,follow">
    <meta name="googlebot" content="index,follow,snippet,archive">
    <link rel="stylesheet" href='/hugo-theme-console/css/terminal-0.7.1.min.css'>
    <link rel="stylesheet" href='/hugo-theme-console/css/animate-3.7.2.min.css'>
    <link rel="stylesheet" href='/hugo-theme-console/css/console.css'>
    
      <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
          <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
      <![endif]-->
    <link rel="icon" 
      type="image/png" 
      href="/favicon-comp.png"><meta property="og:title" content="A Case for the Tidyverse" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/why-tidyverse/" /><meta property="article:published_time" content="2020-04-27T00:00:00+00:00" />



<meta name="twitter:title" content="A Case for the Tidyverse"/>
<meta name="twitter:description" content="The tidyverse is a set of actively developed and well-maintained R packages to facilitate the typical data analysis workflow. Here&rsquo;s why you should use it in your projects."/>

</head>
<body class="terminal">
    <div class="container">
        <div class="terminal-nav">
          <header class="terminal-logo">
            <div class="logo terminal-prompt">
              
              
              <a href="/" class="no-style site-name">data&#43;science</a>:~/ 
              
              <a href='posts'></a> <a href='/'>posts</a>/
              
              <a href='why-tidyverse'></a> <a href='//'>why-tidyverse</a>/
              </div>
            </header>
          <nav class="terminal-menu">
            <ul vocab="https://schema.org/" typeof="BreadcrumbList">
                
                <li><a href="/about/" typeof="ListItem">about/</a></li>
                
                <li><a href="/posts/" typeof="ListItem">posts/</a></li>
                
                <li><a href="/resources/" typeof="ListItem">resources/</a></li>
                
                <li><a href="/tags/" typeof="ListItem">tags/</a></li>
                
            </ul>
          </nav>
        </div>
    </div>

    <div class="container animated zoomIn fast">
        
<h1>A Case for the Tidyverse</h1>

27 Apr 2020 // 27' read

<br/>

  <link rel="stylesheet" href="tomorrow.css" type="text/css" />

<div id="TOC">
<ul>
<li><a href="#intro">Inspiration and Inception</a></li>
<li><a href="#pkgs">Ecosystem</a><ul>
<li><a href="#tibble">Tibbles</a></li>
<li><a href="#magrittr">Pipes</a></li>
<li><a href="#tidyr">Tidying</a></li>
<li><a href="#dplyr">Wrangling</a></li>
<li><a href="#nesting">Nesting</a></li>
<li><a href="#purrr">Functional Programming</a></li>
<li><a href="#stringr.forcats">Strings and Factors</a></li>
</ul></li>
<li><a href="#tldr">TL;DR</a></li>
</ul>
</div>

<div id="intro" class="section level2">
<h2>Inspiration and Inception</h2>
<p>The <a href="https://www.tidyverse.org/packages/">tidyverse</a> is a set of actively developed and well-maintained R packages to facilitate the typical data analysis workflow. Most but not all of the core tidyverse packages (there are now 8) were designed by <a href="http://hadley.nz/">Hadley Wickham</a>, chief scientist at RStudio since 2013. His book <em><a href="https://r4ds.had.co.nz/">R for Data Science</a></em> is an incredible resource that is only roughly summarized in this tutorial.</p>
<!-- Plenty of his talks and interviews are available on YouTube as well; [here's](https://www.youtube.com/watch?v=9YTNYT1maa4) my favorite from the [VIZBI](https://vizbi.org/) conference at EMBL last year.  -->
<p>Many R programmers who don’t explicitly know what the tidyverse is have at least used <code>ggplot2</code>, and if they got their start in base R as I did, probably found it annoying because of the slightly different syntax. The inspiration behind it was to be the first open source implementation of <em><a href="https://towardsdatascience.com/a-comprehensive-guide-to-the-grammar-of-graphics-for-effective-visualization-of-multi-dimensional-1f92b4ed4149">The Grammar of Graphics</a></em> (hence <strong>gg</strong>plot), a statistical textbook from the 1980s that provided a concise way to describe a range of data visualizations. Grammar is simply an attribute of language that dictates how elements must be expressed in order to be understood, and where human languages predominately evolve the grammar that distinguishes them functionally, programming languages can be tailored and tweaked.</p>
<p>The mission of <code>ggplot</code> - getting from data to visualization more intuitively by tweaking the grammar - is what paved the way for the rest of the tidyverse. R users who have ever melted or cast a data frame might be curious to know that those packages were also Hadley’s work and key milestones of the <code>dplyr</code> package in the mature tidyverse. As he puts it, very often the key to creating a visualization is about getting the data in the right form, hence the expansion into data manipulation.</p>
<center>
<img src="data/data.science.process.png" alt="Figure 1 from R for Data Science" /> Canonical data science workflow from <em>R for Data Science</em> <a href="https://r4ds.had.co.nz/tidy-data.html">chapter 1</a>
</center>
<p><br></p>
<p>I like this representation because it contains all the tasks I do as a computational researcher. Regardless of the motivating question, my work starts with data and ends with communicating something learned from the nonlinear process of exploring that data. The tidyverse attracted me because it offered complete workflow coverage and consistency throughout, which felt like the best way to attain fluency and proficiency. The documentation and community helps, too. Once I got into it, I realized that the weird syntax that kept me from liking <code>ggplot2</code> a few years ago is exactly what gives it those attractive qualities.</p>
</div>
<div id="pkgs" class="section level2">
<h2>Ecosystem</h2>
<p>To take a look at the core packages and show my favorite features, let’s load everyone’s least favorite dataset: <strong>mtcars</strong>. It’s a data frame.</p>
<pre class="r"><code>data(mtcars)
head(mtcars)</code></pre>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<p>Let’s transform it to a <a href="https://tibble.tidyverse.org/">tibble</a> and see if you can spot the differences.</p>
<pre class="r"><code>library(tibble)
as_tibble(mtcars)</code></pre>
<pre><code>## # A tibble: 32 x 11
##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
##  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
##  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
##  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
##  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
##  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
##  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
##  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
##  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
## 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
## # … with 22 more rows</code></pre>
<div id="tibble" class="section level3">
<h3>Tibbles</h3>
<p>Three things should stand out: our rownames are missing, the data type of each column is now displayed in the console, and the full dimensions of the data are printed. A bit subtler is that the first 10 rows were automatically displayed without us needing to call <code>head()</code>. If you’re following along in your own R console or R Notebook, there will be stylistic changes too.</p>
<p>Aside from the lack of rownames, which is a philosophy choice of the tidyverse I will get back to shortly, the other changes are upgrades to the data frame in my opinion. I frequently need to peek at my data structures in the console when I’m programming, and always hated having to type e.g. <code>head()</code> or <code>dim()</code> to get information I needed to proceed. I also frequently find out that a bug I’m having is because my column variables are encoded differently than I thought (e.g. an integer rather than a factor). Seeing these attributes of my variables in a tibble without needing to explicitly check for them forces me to confront potential issues early on.</p>
<p>The best programmers are the laziest programmers. Someone said that to me once and it stuck; you can only be lazy if you’re good at what you do.</p>
<p>What’s even better, 99 times out of 100 any function in R that accepts a data frame as an argument will accept a tibble as is without you needing to explicitly use <code>as.data.frame()</code> on it. That’s because a tibble is of class <code>data.frame</code> as well.</p>
<pre class="r"><code>class(as_tibble(mtcars))</code></pre>
<pre><code>## [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</code></pre>
<p>On a data structural level, what differentiates tibbles from data frames and a matrices is that <strong>tibbles cannot have rownames.</strong> That may seem silly, but it’s actually really smart. Including e.g. “SampleID” and treating it as any other column doesn’t really have downsides, but it has the huge upside of never having to call <code>rownames()</code> when coding. The rowname is after all just another variable describing the data - why not treat it as such structurally.</p>
<p>Importantly, as the code chunk above confirms, <strong>tibbles are <em>not</em> equivalent to numeric matrices</strong>, and need to undergo a few transformations before applying functions that require numeric matrices. This is frequently the case in my little biostatistics niche and would reasonably be considered a downside for most (including former me).</p>
<p>The package is aware that many existing R functions work with rownames and/or matrices. There are two <strong>key methods for interconverting between data frames/matrices and tibbles</strong> that I use all the time: one for converting a data frame to a tibble so I can explore it (<code>rownames_to_column()</code>), and another for converting a tibble I’ve been working with to a data frame in order to apply an external function (<code>column_to_rownames()</code>).</p>
<pre class="r"><code># convert data frame with rownames (mtcars) to tibble
as_tibble(rownames_to_column(mtcars, var = &#39;model&#39;))</code></pre>
<pre><code>## # A tibble: 32 x 12
##    model         mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4
##  2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4
##  3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
##  4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
##  5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
##  6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
##  7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
##  8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2
##  9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
## 10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
## # … with 22 more rows</code></pre>
<pre class="r"><code># convert tibble to matrix with rownames;
mtcars.tbl &lt;- as_tibble(rownames_to_column(mtcars, var = &#39;model&#39;))
head(as.matrix(column_to_rownames(mtcars.tbl, var = &#39;model&#39;)))</code></pre>
<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1</code></pre>
<p>If you’re thinking, “I thought she said the tidyverse would <em>save</em> time not <em>add</em> steps” - it’s about the long game, and ultimately, typing two lines to get my data into a tibble first has been <em>way</em> more efficient than repeatedly questioning my data structure (literally, by asking it <code>dim()</code> or <code>head()</code> or <code>class(df$column)</code>) throughout an exploratory analysis/tidying session. I worked exclusively in base R for my MSc thesis and remember being truly enraged for a tiny second each time I accidentally just typed a variable name and watched a huge matrix print to the console - erasing my thought process and forcing me to <em>retype</em> along with the right modifier.</p>
</div>
<div id="magrittr" class="section level3">
<h3>Pipes</h3>
<p>One of the weirdest things about the tidyverse that probably deters beginners, as it did me, is its use of the <strong>pipe</strong> <code>%&gt;%</code> operator. Bioinformaticians coming from other scripting and shell languages might be more comfortable thinking flexibly about operators, but it was pretty foreign to me, even as someone with a formal (albeit distantly so) programming background. I didn’t know any off the top of my head except <code>&lt;-</code> and <code>=</code>.</p>
<p>The learning curve pays off, though. The intent of the pipe is to <strong>make code more readable,</strong> almost like a recipe. Remember, the whole idea of <em>The Grammar of Graphics</em> was to break a data visualization down into raw ingredients, and this same recipe mentality is present in the <code>ggplot2</code> implementation that combines these ingredients in a structured, stepwise way using the <code>+</code> operator. The pipe however comes from the <a href="https://magrittr.tidyverse.org/">magrittr</a> package, but it functions much the same by ‘piping’ the product of a function or calculation forward to another one.</p>
<p>From our above example interconverting between data frames and tibbles, here’s how the pipe operator would execute the same command:</p>
<pre class="r"><code>library(magrittr)

mtcars.tbl &lt;- mtcars %&gt;%
    rownames_to_column(var = &#39;model&#39;) %&gt;%
    as_tibble()</code></pre>
<p>This is the most general way the pipe is used (but not the only one); the first line is always the variable you wish to create, followed by the variable you’re starting with, followed by the <code>%&gt;%</code> operator. In our example, <code>mtcars</code> is fed into <code>rownames_to_column()</code> which doesn’t need us to explicitly give <code>mtcars</code> as a first argument anymore - same with <code>as_tibble()</code>.</p>
<p>In my opinion, this is not only easier to read but also a lot less frustrating when working in the console. I suspect the tidyverse developers work on Macs and aren’t used to having a home/end/insert key, because cursoring around to add parentheses and whatnot without those three keys was the bane of my R existence before I started using pipes.</p>
<p>Importantly, <strong>the pipe only works with tibbles and data frames</strong>, not matrices (hence why we did have to call <code>as.matrix()</code> a few code chunks ago), but its use extends far beyond the tidyverse: the pipe operator and ‘piping’ works for base R commands (like <code>nrow()</code>, provided it’s the end command in your pipe) and functions from specialized packages that read data frames, too.</p>
<p>Here are two equivalent expressions calculating a Spearman correlation matrix from <code>mtcars</code>.</p>
<pre class="r"><code>cor.mat &lt;- cor(mtcars, method = &#39;spearman&#39;)

cor.mat &lt;- mtcars %&gt;%
    cor(method = &#39;spearman&#39;)</code></pre>
<p>The pipe actually makes the code <em>longer</em>, but what about the next step? What if we don’t care at all about the actual correlation matrix and just want to plot it?</p>
<pre class="r"><code># nested function calls
cor.plot &lt;- corrplot::corrplot(cor(mtcars, method = &#39;spearman&#39;))

# intermediate variable stored
cor.mat &lt;- cor(mtcars, method = &#39;spearman&#39;)
cor.plot &lt;- corrplot::corrplot(cor.mat)</code></pre>
<pre class="r"><code># cleanest expression
cor.plot &lt;- mtcars %&gt;%
    cor(method = &#39;spearman&#39;) %&gt;%
    corrplot::corrplot()</code></pre>
<p>There’s a way to pipe to functions that ask for a data frame as the second or third argument, or only want a specific column of your data frame. That is slightly advanced though and I will table it for later along with the <code>purrr</code> package and formula shortcuts.</p>
<p>Hopefully you get the potential, but the real value of the pipe only became clearer to me the more intricate my manipulations and data structures became. I use them pretty exclusively in both my quick and dirty console programming and my polished scripts, and will continue to point out their utility to me.</p>
<p>Straight from the documentation, it makes code more readable by:</p>
<ul>
<li>structuring sequences of data operations left-to-right (as opposed to from the inside and out),</li>
<li>avoiding nested function calls,</li>
<li>minimizing the need for local variables and function definitions, and</li>
<li>making it easy to add steps anywhere in the sequence of operations.</li>
</ul>
<p>It even has a series of <a href="https://magrittr.tidyverse.org/reference/aliases.html">‘aliases’</a> to do common data frame calculations and manipulations (like accessing a specific column), and some that work for subsetting and inserting into lists, too (again, to come later with <code>purrr</code>).</p>
</div>
<div id="tidyr" class="section level3">
<h3>Tidying</h3>
<p>The pipe really shines during the manipulation of raw data into a format that invites further analysis. The core <code>tidyverse</code> packages for carrying this out are <a href="https://tidyr.tidyverse.org/">tidyr</a> and <a href="https://dplyr.tidyverse.org/">dplyr</a>. So what does tidy data refer to, exactly?</p>
<p>It’s a standard format that follows from the basic data structure of the tidyverse, a tibble, in which <strong>1)</strong> every column is a variable, <strong>2)</strong> every row is an observation, and <strong>3)</strong> every cell is a single value. Rownames, then, are not tidy; aside from that, the <code>mtcars</code> data fulfills the other criteria. Here is a visual representation of tidy data.</p>
<center>
<img src="data/tidy.data.rep.png" /> from <em>R for Data Science</em> <a href="https://r4ds.had.co.nz/tidy-data.html">chapter 12</a>
</center>
<p><br></p>
<p>I’m going to switch gears now and look at the <a href="https://www.gapminder.org/data/">gapminder data</a>, which contains several per-country longitudinal metrics, shown below in an <em>untidy</em> format. There are three variables contained in the table pictured below: country name, year, and inflation-adjusted GDP per capita, but these are spread across the rownames, column names, and values, respectively.</p>
<center>
<img src="data/gapminder.png" />
</center>
<p></br></p>
<p>Quickly, we’ll use the existing gapminder <a href="https://github.com/jennybc/gapminder">R package</a> just to see how this same data looks tidied.</p>
<pre class="r"><code>library(tidyr)
library(gapminder)

gapminder %&gt;%
    dplyr::select(c(&#39;country&#39;,&#39;year&#39;,&#39;gdpPercap&#39;))</code></pre>
<pre><code>## # A tibble: 1,704 x 3
##    country      year gdpPercap
##    &lt;fct&gt;       &lt;int&gt;     &lt;dbl&gt;
##  1 Afghanistan  1952      779.
##  2 Afghanistan  1957      821.
##  3 Afghanistan  1962      853.
##  4 Afghanistan  1967      836.
##  5 Afghanistan  1972      740.
##  6 Afghanistan  1977      786.
##  7 Afghanistan  1982      978.
##  8 Afghanistan  1987      852.
##  9 Afghanistan  1992      649.
## 10 Afghanistan  1997      635.
## # … with 1,694 more rows</code></pre>
<p>Tidyr has <strong>two workhorse functions when it comes to tidying data</strong>: <code>pivot_longer()</code> and <code>pivot_wider()</code>, <a href="https://github.com/tidyverse/tidyr/releases/tag/v1.0.0">formerly known as</a> as <code>gather()</code> and <code>spread()</code> respectively, or, as I mentioned earlier, <code>melt()</code> and <code>cast()</code> to some. Don’t get too caught up in the syntax yet, but here’s an animation of these functions in action from the <a href="https://github.com/gadenbuie/tidyexplain">tidyexplain</a> package.</p>
<center>
<img src="data/spread.gather.gif" />
</center>
<p></br></p>
<p><code>pivot_longer()</code> <em>lengthens</em> data and increases the number of rows, allowing us to “gather” our column name values into a column of its own and assigning a key-value pair, and is useful when a variable is stored in column names as is the case with the <code>gapminder</code> data. <code>pivot_wider()</code> <em>widens</em> data and increases the number of columns, allowing us to “spread” the values in a single column across new columns.</p>
<p>Let’s take the long, tidy <code>gapminder</code> data above and pivot it wider into an untidy format, which could have its uses.</p>
<pre class="r"><code>gapminder.wide &lt;- gapminder %&gt;%
    dplyr::select(c(&#39;country&#39;,&#39;year&#39;,&#39;gdpPercap&#39;)) %&gt;%
    pivot_wider(names_from = &#39;year&#39;, 
                values_from = &#39;gdpPercap&#39;) %&gt;%
    print()</code></pre>
<pre><code>## # A tibble: 142 x 13
##    country `1952` `1957` `1962` `1967` `1972` `1977` `1982` `1987` `1992` `1997`
##    &lt;fct&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 Afghan…   779.   821.   853.   836.   740.   786.   978.   852.   649.   635.
##  2 Albania  1601.  1942.  2313.  2760.  3313.  3533.  3631.  3739.  2497.  3193.
##  3 Algeria  2449.  3014.  2551.  3247.  4183.  4910.  5745.  5681.  5023.  4797.
##  4 Angola   3521.  3828.  4269.  5523.  5473.  3009.  2757.  2430.  2628.  2277.
##  5 Argent…  5911.  6857.  7133.  8053.  9443. 10079.  8998.  9140.  9308. 10967.
##  6 Austra… 10040. 10950. 12217. 14526. 16789. 18334. 19477. 21889. 23425. 26998.
##  7 Austria  6137.  8843. 10751. 12835. 16662. 19749. 21597. 23688. 27042. 29096.
##  8 Bahrain  9867. 11636. 12753. 14805. 18269. 19340. 19211. 18524. 19036. 20292.
##  9 Bangla…   684.   662.   686.   721.   630.   660.   677.   752.   838.   973.
## 10 Belgium  8343.  9715. 10991. 13149. 16672. 19118. 20980. 22526. 25576. 27561.
## # … with 132 more rows, and 2 more variables: `2002` &lt;dbl&gt;, `2007` &lt;dbl&gt;</code></pre>
<p>Now it looks like our image above. Let’s pretend that <code>gapminder.wide</code> is our raw data and we need to tidy it. We’ll use <code>pivot_longer()</code> this time, telling it to ignore the country (<code>cols = -country</code>), and gather the other column names into a variable called ‘year’, and the corresponding values into a variable called ‘gpdPercap’. We didn’t have to tell <code>pivot_wider()</code> to ignore any variables/columns, because our starting <code>gapminder.long</code> data only had three variables.</p>
<pre class="r"><code>gapminder.long &lt;- gapminder.wide %&gt;%
    pivot_longer(cols = -country,
                 names_to = &#39;year&#39;,
                 values_to = &#39;gdpPercap&#39;) %&gt;%
    print()</code></pre>
<pre><code>## # A tibble: 1,704 x 3
##    country     year  gdpPercap
##    &lt;fct&gt;       &lt;chr&gt;     &lt;dbl&gt;
##  1 Afghanistan 1952       779.
##  2 Afghanistan 1957       821.
##  3 Afghanistan 1962       853.
##  4 Afghanistan 1967       836.
##  5 Afghanistan 1972       740.
##  6 Afghanistan 1977       786.
##  7 Afghanistan 1982       978.
##  8 Afghanistan 1987       852.
##  9 Afghanistan 1992       649.
## 10 Afghanistan 1997       635.
## # … with 1,694 more rows</code></pre>
</div>
<div id="dplyr" class="section level3">
<h3>Wrangling</h3>
<p>Once the data is tidied, the <code>dplyr</code> package becomes essential to “wrangle” it further. Like <code>ggplot2</code>, <code>dplyr</code> is “a <em>grammar</em> of data manipulation. Practically what this means is that the functions and corresponding parameter names are intended to help you translate your thoughts into code more quickly, and vice versa.</p>
<p>The basic function are as follows:</p>
<ul>
<li><code>mutate()</code> adds new variables (columns) that are functions of existing variables</li>
<li><code>select()</code> picks variables (columns) based on their names</li>
<li><code>filter()</code> picks cases (rows) based on their values</li>
<li><code>summarise()</code> reduces multiple values down to a single summary</li>
<li><code>arrange()</code> changes the ordering of the rows</li>
</ul>
<p>As these are such common data manipulations, they of course have <a href="https://tavareshugo.github.io/data_carpentry_extras/base-r_tidyverse_equivalents/base-r_tidyverse_equivalents.html">base R equivalents</a>, like much of the <code>dplyr</code> package. To be totally honest, aside from <code>subset()</code> (equivalent to <code>filter()</code>) and <code>sort()</code>/<code>order()</code> (equivalent to <code>arrange()</code>), I never used any of these. <code>subset()</code> has the exact same syntax as <code>filter()</code>, and I’m not going to argue that there are specific advantages to using <code>dplyr</code> if you’re already a pro at base R manipulations.</p>
<p>I wasn’t, and personally found having a <strong>dedicated and flexible package to master</strong> for this purpose incredibly beneficial. The basic functions above were intuitive enough to learn and deploy quickly, and each time I encounted a specific problem wrangling my data I was able to find a clean solution by reading the <a href="">documentation</a> or studying the <a href="">cheetsheat</a>, which over time I incorporated into my toolbox as well.</p>
<p>Let’s dive into some of these, switching back to <code>mtcars</code>. If we look at our <code>mtcars.tbl</code> again, we can see that some of the columns are ‘dbl’ when they should actually be factors (‘fctr’). This has to do with tibbles being ‘lazy’, i.e. they do not guess data types and encode variables as either character or numeric whenever possible.</p>
<pre class="r"><code>mtcars.tbl</code></pre>
<pre><code>## # A tibble: 32 x 12
##    model         mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4
##  2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4
##  3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
##  4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
##  5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
##  6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
##  7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
##  8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2
##  9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
## 10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
## # … with 22 more rows</code></pre>
<pre class="r"><code>library(dplyr)

mtcars.tbl %&gt;%
    mutate(cyl = as.factor(cyl))</code></pre>
<pre><code>## # A tibble: 32 x 12
##    model         mpg cyl    disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &lt;chr&gt;       &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Mazda RX4    21   6      160    110  3.9   2.62  16.5     0     1     4     4
##  2 Mazda RX4 …  21   6      160    110  3.9   2.88  17.0     0     1     4     4
##  3 Datsun 710   22.8 4      108     93  3.85  2.32  18.6     1     1     4     1
##  4 Hornet 4 D…  21.4 6      258    110  3.08  3.22  19.4     1     0     3     1
##  5 Hornet Spo…  18.7 8      360    175  3.15  3.44  17.0     0     0     3     2
##  6 Valiant      18.1 6      225    105  2.76  3.46  20.2     1     0     3     1
##  7 Duster 360   14.3 8      360    245  3.21  3.57  15.8     0     0     3     4
##  8 Merc 240D    24.4 4      147.    62  3.69  3.19  20       1     0     4     2
##  9 Merc 230     22.8 4      141.    95  3.92  3.15  22.9     1     0     4     2
## 10 Merc 280     19.2 6      168.   123  3.92  3.44  18.3     1     0     4     4
## # … with 22 more rows</code></pre>
<p>That’s great, but I can see that the last four columns could all be factors as well and I don’t want to do it for each column. <code>select()</code>, and all the other basic <code>dplyr</code> functions above provide extremely helpful <a href="https://dplyr.tidyverse.org/reference/scoped.html">variants</a> to this effect.</p>
<p>Adding the <code>_at()</code> suffix to any of the basic commands above allows me to specify column names or indices to manipulate multiple columns at once, while the <code>_all()</code> suffix allows me to manipulate all columns (in which case I need to pay attention to types and make sure what I’m doing will work for all columns). Lastly, the <code>_if()</code> suffix allows me to specify a logical (TRUE/FALSE output) function or condition to selectively affect columns.</p>
<p>To get an idea of the scope of the categorical variables in <code>mtcars.tbl</code>, we’ll first <code>mutate()</code> the variables we suspect are factors by name, then we’ll <code>select()</code> only those columns, and finally we will <code>summarize()</code> each factor variable and compress all of our observations into a summary statistic, <code>nlevels</code>.</p>
<pre class="r"><code>mtcars.tbl %&gt;% 
    mutate_at(c(&#39;cyl&#39;,&#39;vs&#39;,&#39;am&#39;,&#39;gear&#39;,&#39;carb&#39;), as.factor) %&gt;%
    select_if(is.factor) %&gt;%
    summarize_all(nlevels)</code></pre>
<pre><code>## # A tibble: 1 x 5
##     cyl    vs    am  gear  carb
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1     3     2     2     3     6</code></pre>
<p>The last two basic functions are <code>filter()</code> and <code>arrange()</code>. To introduce those with a very practical question, what if I’m only curious about the mileage for cars with 8 cylinders and 3 gears? We can start with our <code>mtcars.tbl</code> without converting any of the factors. We’ll <code>filter()</code> according to <code>cyl</code>, and then <code>arrange()</code> our data by <code>mpg</code> in <code>desc</code>ending order.</p>
<p>In the last line of code there is a nice subtlty of the <code>dplyr</code> syntax: earlier when we used <code>select()</code> we specified our column names as character vector, but it also works with the variable names directly as shown here.</p>
<pre class="r"><code>mtcars.tbl %&gt;%
    filter(cyl == 8 &amp; gear == 3) %&gt;%
    arrange(desc(mpg)) %&gt;% 
    select(model, cyl, gear, everything())</code></pre>
<pre><code>## # A tibble: 12 x 12
##    model         cyl  gear   mpg  disp    hp  drat    wt  qsec    vs    am  carb
##    &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Pontiac Fi…     8     3  19.2  400    175  3.08  3.84  17.0     0     0     2
##  2 Hornet Spo…     8     3  18.7  360    175  3.15  3.44  17.0     0     0     2
##  3 Merc 450SL      8     3  17.3  276.   180  3.07  3.73  17.6     0     0     3
##  4 Merc 450SE      8     3  16.4  276.   180  3.07  4.07  17.4     0     0     3
##  5 Dodge Chal…     8     3  15.5  318    150  2.76  3.52  16.9     0     0     2
##  6 Merc 450SLC     8     3  15.2  276.   180  3.07  3.78  18       0     0     3
##  7 AMC Javelin     8     3  15.2  304    150  3.15  3.44  17.3     0     0     2
##  8 Chrysler I…     8     3  14.7  440    230  3.23  5.34  17.4     0     0     4
##  9 Duster 360      8     3  14.3  360    245  3.21  3.57  15.8     0     0     4
## 10 Camaro Z28      8     3  13.3  350    245  3.73  3.84  15.4     0     0     4
## 11 Cadillac F…     8     3  10.4  472    205  2.93  5.25  18.0     0     0     4
## 12 Lincoln Co…     8     3  10.4  460    215  3     5.42  17.8     0     0     4</code></pre>
<p>The last thing about <code>dplyr</code> that I think is really worth mentioning is the <code>group_by()</code> function, which is similar to <code>aggregate()</code> in base R and allows us to group our rows by any variable we like. If we told it to group by a continuous variable such as mpg, it would essentially call <code>unique(mpg)</code> and create a separate group for each.</p>
<p>To use a practical example though, let’s say we want the average mpg broken down by the number of cylinders. First we’ll <code>select()</code> both columns, then <code>group</code> our rows <code>_by(cyl)</code> before we <code>summarize(mpg)</code>, which will respect our groups. If we removed the <code>group_by()</code> command, we would get a single summary statistic of <em>all</em> rows - the average <code>mpg</code> of all data regardless of <code>cyl</code>.</p>
<pre class="r"><code>mtcars.tbl %&gt;%
    select(cyl, mpg) %&gt;%
    group_by(cyl) %&gt;%
    summarize(avg.mpg = mean(mpg))</code></pre>
<pre><code>## # A tibble: 3 x 2
##     cyl avg.mpg
##   &lt;dbl&gt;   &lt;dbl&gt;
## 1     4    26.7
## 2     6    19.7
## 3     8    15.1</code></pre>
<p>Another syntax subtlety to point out: when we used the <code>_all()</code> variant of the <code>summarize()</code> function earlier, we only had to give the name of the summary function, but with the basic <code>summarize()</code> function here, we had to specify inside of the function which columns we wanted to summarize. We could have also written <code>summarize(mean(mpg))</code> and the <code>avg.mpg</code> column would read <code>mean(mpg)</code> instead but hold the same values.</p>
</div>
<div id="nesting" class="section level3">
<h3>Nesting</h3>
<p><code>group_by()</code> is really handy - but what if I want to incorporate the <code>avg.mpg</code> as a new column in <code>mtcars.tbl</code> instead of just extracting or peeking at the values as we did above? Enter <code>nest()</code> from <code>tidyr</code>, which will create a <strong>list-column</strong>, i.e. a column of our tibble that is actually a list.</p>
<p>Here’s what that looks like with <code>mtcars.tbl</code> if we split the data into groups according to <code>cyl</code> again.</p>
<pre class="r"><code>mtcars.tbl %&gt;%
    nest(data = -cyl)</code></pre>
<pre><code>## # A tibble: 3 x 2
##     cyl data              
##   &lt;dbl&gt; &lt;list&gt;            
## 1     6 &lt;tibble [7 × 11]&gt; 
## 2     4 &lt;tibble [11 × 11]&gt;
## 3     8 &lt;tibble [14 × 11]&gt;</code></pre>
<p>Peeking at the data we just nested, i.e. the 3rd tibble in our new list-column, will give us all the corresponding variables for car models with 8 cylinders.</p>
<pre class="r"><code>mtcars.nest &lt;- mtcars.tbl %&gt;%
    nest(data = -cyl)

mtcars.nest$data[[3]]</code></pre>
<pre><code>## # A tibble: 14 x 11
##    model               mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb
##    &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Hornet Sportabout  18.7  360    175  3.15  3.44  17.0     0     0     3     2
##  2 Duster 360         14.3  360    245  3.21  3.57  15.8     0     0     3     4
##  3 Merc 450SE         16.4  276.   180  3.07  4.07  17.4     0     0     3     3
##  4 Merc 450SL         17.3  276.   180  3.07  3.73  17.6     0     0     3     3
##  5 Merc 450SLC        15.2  276.   180  3.07  3.78  18       0     0     3     3
##  6 Cadillac Fleetwo…  10.4  472    205  2.93  5.25  18.0     0     0     3     4
##  7 Lincoln Continen…  10.4  460    215  3     5.42  17.8     0     0     3     4
##  8 Chrysler Imperial  14.7  440    230  3.23  5.34  17.4     0     0     3     4
##  9 Dodge Challenger   15.5  318    150  2.76  3.52  16.9     0     0     3     2
## 10 AMC Javelin        15.2  304    150  3.15  3.44  17.3     0     0     3     2
## 11 Camaro Z28         13.3  350    245  3.73  3.84  15.4     0     0     3     4
## 12 Pontiac Firebird   19.2  400    175  3.08  3.84  17.0     0     0     3     2
## 13 Ford Pantera L     15.8  351    264  4.22  3.17  14.5     0     1     5     4
## 14 Maserati Bora      15    301    335  3.54  3.57  14.6     0     1     5     8</code></pre>
<p>Whereas the <code>summarize()</code> function <em>transformed</em> our data, <code>nest()</code> <em>restructured</em> our data. You could generalize this to the package level and say that <code>dplyr</code> primarily transforms and <code>tidyr</code> primarily restructures. Of course, we still need to transform it in order to get the average mpg, but I want to pause here and discuss why one would want to restructure their data, in case it’s not immediately obvious.</p>
<p>First, especially since it’s a tidyverse function and therefore built to work with tibbles, nesting is a super <strong>visually appealing and an easy way to get specific peeks into your data</strong>. This would be the basic use case. We can quickly see the number of observations/rows associated with our grouping variable, since the dimensions of the tibble are displayed, without having to calculate that specifically.</p>
<p>More importantly though, <strong>nesting and list-columns are somewhat of a portal within the tidyverse</strong>. Up until <code>nest()</code>, we had been working with a single data structure: a tibble, a data frame. A familiar and incredibly handy structure made up of rows, columns and values. In R, a data frame is distinct from a matrix because it can hold values of different data types. In other words, the values must be numeric in a matrix, but they can be characters, factors, and/or strings in a data frame.</p>
<p><code>tidyr</code> <strong>standardized the data frame</strong> such that all rows were observations and all columns were variables, but it also <strong>allows values to be anything</strong> - even another data frame (or a model, or an object, or a plot). This is the beauty of functional programming and the <code>purrr</code> package, and it’s actually what brought me to adopt the tidyverse. It’s absolutely brilliant because it <strong>harnesses the advantages of both data frames and lists</strong>. More on this to come in a more programming-heavy post.</p>
<!-- For me this is a natural place to pause because the discovery of nested list-columns was the beginning of an exponential growth phase in my interest to program - a portal. While I do hope to make programming more accessible and intuitive to everyone reading this, I recognize the primary audience will likely be split between those using R to do somewhat cut-and-dry manipulations like we've done here (perhaps to achieve simple correlations or visualizations), and those using R to do more complex and custom manipulations like modelling and simulation, and I want to respect that delineation.  -->
<!-- As the name of this part of the tutorial suggests, much like a biological [ecosystem](#pkgs) the tidyverse works because while the entities (packages, functions) are specialized, they share common concepts (syntax, structures) that allow them to flexibly adapt to different problems (modelling, visualization). I hope those also working in biology can appreciate the metaphors as much as I do. -->
<!-- As the [workflow](#intro) in the introduction showed, exploratory data analysis is an iterative, nonlinear process. I have tried to introduce it in a linear fashion to emphasize the tools, but in reality few tasks are as simple as these. I and many others came to R to solve messy and complex biological problems that we don't know the answer to, which require many more transformations and use of specialized packages or functions to even get to better questions most of the time. While everything that's been introduced so far still facilitates that process to some degree in my opinion, it's literally the tip of the iceberg.  -->
<!-- When I started my PhD, I was tasked with eventually simulating multi-omics datasets. -->
<p>To wrap up our <code>mtcars</code> example where we create and incorporate the <code>avg.mpg</code> variable into <code>mtcars.tbl</code> as a sneak peek, here’s how that’s done using <code>map_dbl()</code> from the <code>purrr</code> package, which maps a given function over every element in a list and returns a double which we’ve designated <code>avg.mpg</code>.</p>
<pre class="r"><code>mtcars.nest &lt;- mtcars.tbl %&gt;%
    nest(data = -cyl) %&gt;%
    mutate(avg.mpg = purrr::map_dbl(data, ~ mean(.$mpg))) %&gt;%
    print()</code></pre>
<pre><code>## # A tibble: 3 x 3
##     cyl data               avg.mpg
##   &lt;dbl&gt; &lt;list&gt;               &lt;dbl&gt;
## 1     6 &lt;tibble [7 × 11]&gt;     19.7
## 2     4 &lt;tibble [11 × 11]&gt;    26.7
## 3     8 &lt;tibble [14 × 11]&gt;    15.1</code></pre>
<p>And of course, you can <code>unnest()</code>, which will fill in the same group <code>avg.mpg</code> for rows which share a <code>cyl</code> value.</p>
<pre class="r"><code>mtcars.nest %&gt;%
    unnest(data) %&gt;%
    select(model, avg.mpg, cyl, mpg)</code></pre>
<pre><code>## # A tibble: 32 x 4
##    model          avg.mpg   cyl   mpg
##    &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Mazda RX4         19.7     6  21  
##  2 Mazda RX4 Wag     19.7     6  21  
##  3 Hornet 4 Drive    19.7     6  21.4
##  4 Valiant           19.7     6  18.1
##  5 Merc 280          19.7     6  19.2
##  6 Merc 280C         19.7     6  17.8
##  7 Ferrari Dino      19.7     6  19.7
##  8 Datsun 710        26.7     4  22.8
##  9 Merc 240D         26.7     4  24.4
## 10 Merc 230          26.7     4  22.8
## # … with 22 more rows</code></pre>
</div>
<div id="purrr" class="section level3">
<h3>Functional Programming</h3>
<p>Coming soon <!-- 21.4 For loops vs. functionals --> <!-- For loops are not as important in R as they are in other languages because R is a functional programming language. This means that it’s possible to wrap up for loops in a function, and call that function instead of using the for loop directly. --></p>
</div>
<div id="stringr.forcats" class="section level3">
<h3>Strings and Factors</h3>
<p>Coming soon <!-- mutate_at --> <!-- - stringr - str_detect with filter --> <!-- - forcats for factors - useful before plotting --> <!-- - ideal for working with two annoying data types --></p>
</div>
</div>
<div id="tldr" class="section level2">
<h2>TL;DR</h2>
<p>The typical data analysis project is a set of interconnected steps - a workflow - and there are benefits to using programming as a tool throughout, including automation and reproducibility (it’s easy to save and rerun code), as well as the ability to handle more difficult problems later on. For example, it can be a lot more efficient to use programming to solve plotting problems instead of Illustrator (with some practice).</p>
<p>R is an open source programming language already tailored to statistical analysis. Its base implementation enables extensive modelling and visualization, and thousands of specialized packages and niches have emerged on top of this (e.g. <code>phyloseq</code> for the microbiome community). The tidyverse is a large initiative to streamline the entire data analysis workflow by encompassing what comes before and after statistical analysis into a coherent set of packages.</p>
<p>It involves learning some new syntax, and some lingo. For light R users, simply investing in <a href="#tibble">tibbles</a> and the <a href="#magrittr">pipe</a> (<code>%&gt;%</code>) operator will allow you to interact with your raw data in a less frustrating and error-prone manner and generate more readable code. Similarly, understanding even a little bit <a href="#intro">how</a> <code>ggplot2</code> was structured might make working with it a bit more intuitive.</p>
<p>For those working extensively in R, committing to that as well as <a href="#tidyr">tidy</a> data structures will make you a better, more curious programmer. Especially if you are self-taught, the tidyverse provides the quickest path to proficiency for data analysis in R, not only because it’s clever and coherent but because it’s got resources for days: the <a href="https://tidyverse.tidyverse.org/">documentation</a> is immaculate, there are <a href="https://rstudio.com/resources/cheatsheets/">cheatsheets</a> as well as <a href="https://rstudio.com/resources/books/">programming textbooks</a> all freely available, plus an active developer and user community on GitHub and Stack Overflow.</p>
<p>Mastery of the basics opens up a wealth of more advanced tools that I am excited to advocate for and explore in future posts, like deeply nested data structures and functional programming with the <code>purrr</code> package.</p>
<!-- Among human languages one could reasonably posit that English is easier to learn than German, but German allows more precision in expression. Among programming languages, the tidyverse was designed to combine the simplicity of English syntax (literally) with the precision of German grammar (figuratively). -->
<style type="text/css">
img {
    display: block;
    margin-left: auto;
    margin-right: auto;
    width: 70%;
    padding: 10px
}
</style>
</div>


tagged:  ecrc  forslund-lab  programming  r-stats  theory  tidyverse   
        <div class="footer">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://www.netlify.com/">Netlify</a>. 
</div>
    </div>
  </body>
</html>
