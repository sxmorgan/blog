---
title: 'Introduction to the Tidyverse'
subtitle: 'COVID-19 Testing in the US'
author: Morgan Essex
date: '2020-04-27'
slug: tidyverse-covid-19
output:
  blogdown::html_page:
    toc: true
tags:
  - tidyverse
  - R
---

### Tidy Philosophy
The [tidyverse](https://www.tidyverse.org/packages/) is a set of actively developed and well-maintained R packages tailored to the typical data analysis workflow. While the syntax will be unfamiliar to base R users, and many common base functions (such as `subset()`) have tidy counterparts, the two do _not_ exist in a dichotomy: there is no tidyverse without base R, and your favorite base R functions are likely amenable to tidy syntax, which we'll get into briefly later.

Most but not all of the tidyverse has been designed by [Hadley Wickham](http://hadley.nz/), chief scientist at R Studio since 2013 and data enthusiast for a lot longer than that. In 2007 he published `ggplot2`, an open source implementation of [The Grammar of Graphics](https://towardsdatascience.com/a-comprehensive-guide-to-the-grammar-of-graphics-for-effective-visualization-of-multi-dimensional-1f92b4ed4149) (hence **gg**plot). This was a statistical textbook from the 1980s that attempted to break data visualization down into common elements so that it could be built back up in a more consistent, structured manner.

This approach was broadly applied and refined to other the other packages do the same for _their_ respective portion of the data analysis process, shown below. 

![[R for Data Science](https://r4ds.had.co.nz/introduction.html#what-you-will-learn)](../data/covid-tidyverse/data.science.process.png)

We're going to be using data from the COVID Tracking Project in the US. The API is easily accessible, and a woman already created a wrapper package for R to make accessing historical and current statistics incredibly simple.


![](../data/covid-tidyverse/covidtracking.png)

### Import

Calling `library(tidyverse)` will load all the functions we'll need today, except we must also import `magrittr`, which provides us with the pipe (`%>%`) operator for chaining syntax.
```{r knitr, include = FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

```{r libraries}
library(tidyverse)  # data science toolkit
library(magrittr)   # corresponding operators
library(covid19us)  # scrapes https://covidtracking.com/ API
library(ggsci)      # custom color palettes
library(ggpubr)     # publication-ready plots
```

Then, let's load the complete longitudinal dataset and select the variables that will be relevant for our analysis.

```{r load.data.1}
states.data <- get_states_daily() %>%
    select(c('state','date','positive','negative','death','total_test_results'))

states.data
```

Additionally, we're going to pull a csv file from https://worldpopulationreview.com/ that contains state-abbreviation pairs (e.g. CA, California) that we'll use later to 'beautify' our plots.

```{r load.data.2}
states.abbrev <- read_csv('https://worldpopulationreview.com/static/states/abbr-name-list.csv')

states.abbrev
```

Lastly, from that same website I have downloaded the (projected) 2020 census estimates, which we'll read in and use to standardize our data to tests per 100,000 residents.

```{r load.data.3}
states.population <- '../data/covid-tidyverse/covid.us.state.population.csv' %>%
    read_csv() %>%
    select(c('rank','State','Pop'))

states.population
```


### Munge
To munge is to manipulate raw data. We'll start by combining the three different datasets we have loaded to look at testing rates among the most populated states.

```{r munge.1}
testing.data <- states.data %>%
    left_join(states.abbrev, by = c('state' = 'abbreviation')) %>%
    left_join(states.population, by = c('name' = 'State'))

# peeking at newly joined variables
testing.data %>%
    select(c('state','date','name','rank','Pop'))
```

Then we'll use the lubridate package within the tidyverse to quickly split the dates into month and day components so we can look at data from the 9th of March.

```{r munge.2}
testing.data %<>%
    mutate(month = lubridate::month(date)) %>%
    mutate(day = lubridate::day(date)) %>%
    filter(month >= 3) %>%
    filter(day >= 9)

testing.data %>%
    select(c('state','date','total_test_results','month','day'))
```


### Plot
